MultiMoon Map
Darin Ragozzine
February 15, 2020

maybe "MultiMoon" should mean "Multi-ple effects on Moon" or "Multi-ple Moon(s)"


Try to adhere to PEP8 standards
 - 4 spaces for identation level
 - row length < 79 characters
 - triple double-quote (""") docstrings for functions
 - double-quotes for strings


Dataframes saved as csv files should be transposed so that the dataframes are easier to read? 
"Global" variables may be able to not be global by using xargs, but probably fine to be global



Files: 
./src/
mm_run.py
mm_init_guess.py

./src/prep
 - files needed to convert from older codes, etc. to MultiMoon ready codes
 - code to produce geoentric_object_position.csv if it doesn't already exist



mm_run.py 
 - script
 - Input: filename that is a JSON text file version of run_props dictionary
 - Output: directly, information about the success of the run
 - Output: indirectly: posterior, plots, etc.

Works with run_props dictionary
 - Reads in run_props dictionary (from JSON)
 - Adds information autogenerated for this specific run
 - Checks other information

Generates Initial Guess
Make param_to_fit_scale: a parameters dataframe with the scale we'll use for converting to the fit values
default: param_to_fit_scale is the first row of the init_guess dataframe
 - that way, every system and every parameter is pretty naturally scaled automatically!

Checks if geocentric_object_position.csv already exists; if not, creates it; then reads it in and stores it somewhere global

Opens obsdata file and puts it into dataframe and stores it somewhere global

Initializes Run
Chooses prior and likelihood methods

Runs emcee

Takes posterior from emcee, thins, converts from fit_array to posterior dataframe in parameter format
Saves posterior dataframe to designated output file

Makes requested plots


These files are primarily sets of functions. These are numbered. 

mm_init_guess.py

1) gen_init_guess_from_dist
Input: filename/dataframe in parameter-generator format, nwalkers
Ouptut: "init_guess" dataframe in parameter format, nwalkers rows

Uses the information in the parameter-generator format to make Initial Guess dataframe
Note: Very similar code could be used for gen_startguess_from_prior


LATER: 
2) get_init_guess_from_multirow_startguess
Input: "starting guess" parameters filename/dataframe in parameter format, nwalkers
Output: init_guess dataframe in parameter format, nwalkers rows
If len(starting_guess) < nwalkers
 - then need to generate new guesses to append to starting_guess
 - draw randomly parameter by parameter from each column to fill init_guess

If len(starting_guess) > nwalkers
 - draw random number of rows from starting_guess to make init_guess

3) get_init_guess_from_singlerow_startguess_rough
If a single starting guess, then draw nwalkers random rows from distribution of parameter + sqrt(parameter) 

4) get_init_guess_from_prior



mm_priors.py
1) log_prior
Input: prior parameters dataframe in parameter-generation format, list of parameters in parameter format
Output: log of the prior probability



mm_params.py
1) from_param_df_to_fit_array
Input: parameters dataframe, fix/float/constrain, param_to_fit_scale
Output: fit_array, param_to_fit_info dictionary

 - emcee takes an array of floats (nwalkers vs. nfitparams) and it's better if they've been moved and scaled


Needs to be some way to describe how the params were put into the fit array and what to use for fixed values
param_to_fit_info dictionary
each column name (e.g., parameter name like j2r2_2) in the parameter dataframe is a key and the associated value is
 - float: an index number for the value in the fit_array
 - fix: the value to be fixed at


Takes a parameters dataframe and convert them to a fit array
 - for an arbitrary number of rows 
 - only for floating columns
 - scale using param_to_fit_scale
 - rework ecc and aop into ecc*cos(aop), ecc*sin(aop), 
 - rework inc and capom into tan(inc/2)*sin(lan), tan(inc/2)*cos(lan)
 - Later: deal with case where ecc/aop or inc/capom aren't both fixed/floating
 - Later: consider using Thiele-Innes elements (way more linear!) to speed up computation


2) from_fit_array_to_param_df
Input: fit_array, param_to_fit_info, param_to_fit_scale
Output: dataframe in parameter format

Turn the fit_array into the parameter dataframe format (undoing from_param_df_to_fit_array). 



mm_spinny.py
See files from Seth, but something like
1) initialize_spinny - take fit_array and turn it into param dataframe and then add any additional information 
(e.g., default values for unspecificed variables) needed to set up everything that SPINNY needs
2) run_spinny - get dataframe of information about positions relative to primary at specified times
3) run_kepler - if only two objects and no non-Keplerian positions, use spiceypy to get relative positions fast and easy)
4) puts results in model dataframe


mm_relast.py
Compute relative astrometry
1) convert_ecl_rel_pos_to_geo_rel_ast - convert eclptic 
Input: ecliptic relative positions, observer-object relative positions (both in J2000 ecliptic coordinates)
Output: delta(long), delta(lat) on sky (in arcseconds) 
Take relative ecliptic positions (e.g., distance in x, y, z of object j from object 1 in J2000 ecliptic coordinates) and 
and calculate delta(long), delta(lat) including possible photocenter-objectcenter corrections (initially assume zero). 
 - Should just be a simple angle calculation, but careful to use great circle, haversine, etc. so this is clean and easy
 - possibly already in spiceypy? 

Later: 
Allow for corrected positions of observer vs. geocenter
Photocenter-objectcenter corrections (here "objectcenter" means the center of mass of the object; not using "barycenter" since this coudl be confused with system barycenter)



mm_likelihood.py
1) log_likelihood
emcee's code that it calls
Input: fit_array
Output: log likelihood
Calls a sequence of other functions (fit_array_to_param_df, mm_spinny, mm_relast, mm_chisquare, log_prior, etc.) to get everything needed for loglikelihood


2) mm_chisquare
Input: Model Dataframe, Observation Dataframe
Output: chi-square 

Calculate chi-square from model and observation assuming Gaussian errors

Later: allow for loglikehood maps for observed relative astrometry 



mm_plots.py
make plots







RunProps entries
Date - autogenerate
Time - autogenerate
MultiMoon commit hash - autogenerate
Function name from mm_initguess - default = "get_init_guess_from_dist"
Filename for starting guess - default = start_guess.csv
User - autogenerate from whoami
RunGoal - default="unknown"
nobjects - number of objects in the integration, including Sun
objname - name of object, default = "Haumea"
nwalkers - default=30
nsteps - default=1001
nthinning - default=100 (how frequently to report output)
fixfloat_df - default="all float" dataframe in parameters format
lpriorfunc - default="log_prior"
llhoodfunc - default="log_likelihood"
obsdata - name of file with text/csv of observations dataframe
posteriorfile - name of file for posterior, default="date_time_objname.csv"
verbose - default=1, how verbose to be in terms of output
(0 = quiet, no text; 1 = typical, only major outputs, 5 = everything) 
plotflags: True if this plot is to be made, False if not
plot_model_in_data - show model in data space
plot_model_over_time - show model continuous in time over data space
other plots too




Dataframe
name_1 - name of primary (string) 
mass_1 - mass of primary (km^3 * s^2 / G)
name_2 - name of second object
mass_2 - mass of second object
sma_2 - semi-major axis of second object (in primaricentric orbit, km)
ecc_2 - eccentricity of second object (in primaricentric)
aop_2 - argument of periapse (rad)
inc_2 - inclination (rad)
lan_2 - longitude of ascending node (rad)
mea_2 - mean anomaly (rad)
name_3 - name of third object
mass_3 - mass of third object
sma_3 - semi-major axis of second object (in primaricentric orbit, km)
ecc_3 - eccentricity of second object (in primaricentric)
aop_3 - argument of periapse (rad)
inc_3 - inclination (rad)
lan_3 - longitude of ascending node (rad)
mea_3 - mean anomaly (rad)
[More later]
j2r2_1 - J_2*R^2 of primary (km^2)
c22r2_1 - C_22*R^2 of primary (km^2)
spaop_1 - aop-like angle for spin axis of primary (rad, J2000 ecliptic)
spinc_1 - inc-like angle for spin axis of primary (rad)
splan_1 - lan-like angle for spin axis of primary (rad)
sprate_1 - spin (angular) frequency of primary (rad/s)





How to run MultiMoon-
1) Prep = Setup RunProps dictionary
2) mm_run.py runprops.txt


