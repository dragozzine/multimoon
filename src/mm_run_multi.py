# mm_run.py
# 
# The main script that runs MultiMoon
# Darin Ragozzine
# March 27, 2020

"""Run MultiMoon

Inputs:
	filename that is a JSON text file version of run_props dictionary

Outputs:
	diagnostic information about the run

"""
def initializer():
    print('Starting MultiMoon')
    import os
    import mm_runprops
    os.environ["OMP_NUM_THREADS"] = "1"
    cwd = os.getcwd()
    runs_file = ''
    if 'runs' in cwd:
        runs_file = os.path.basename(os.path.normpath(cwd))
        os.chdir('../../../src')
    import sys
    import numpy as np
    import pandas as pd
    import emcee
    import random
    import h5py
    from tqdm import tqdm
    import mm_init_guess
    import mm_likelihood
    import mm_make_geo_pos
    import mm_priors
    import mm_relast
    import mm_autorun
    import mm_param
    import mm_clustering
    import mm_analysis
    #import mm_plots_multi
    import warnings
    import shutil
    import commentjson as json
    from multiprocessing import Manager
    from csv import writer
    
    #from multiprocessing import Pool, Manager
    #from schwimmbad import MPIPool
    #from mpipool import Pool
    
    return sys, np, pd, emcee, random, h5py, mm_runprops, mm_init_guess, mm_likelihood, mm_make_geo_pos, mm_priors, mm_relast, mm_autorun, mm_param, mm_clustering, os, mm_analysis, warnings, shutil, json, writer, Manager, tqdm

# Read in the run props dictionary
# Adds information autogenerated for this specific run
# Checks other information
#print('MultiMoon first line')
import warnings
warnings.filterwarnings("ignore", message="divide by zero encountered")
warnings.filterwarnings("ignore", message="Gimbal lock detected")
warnings.filterwarnings("ignore", message="invalid value encountered in arccos")
warnings.filterwarnings("ignore", message="invalid value encountered in cos")
warnings.filterwarnings("ignore", message="invalid value encountered in sin")
#print('warnings done')
if __name__ == '__main__':

    from schwimmbad import MPIPool
    #print('schwimmbad in')
    with MPIPool() as pool:
        #print('mpipool pooled')    
        if not pool.is_master():
            pool.wait()
            sys.exit(0)
        #print('initializer')  
        sys, np, pd, emcee, random, h5py, mm_runprops, mm_init_guess, mm_likelihood, mm_make_geo_pos, mm_priors, mm_relast, mm_autorun, mm_param, mm_clustering, os, mm_analysis, warnings, shutil, json, writer, Manager, tqdm = initializer()

        #print(os.getcwd())
        
        best_llhoods = {}
        best_llhoods['best_llhood'] = -np.inf
        best_llhoods['best_params'] = []
    
        runprops = mm_runprops.runprops
        runprops['best_llhood'] = -np.inf
    
        verbose = runprops.get("verbose")
        nwalkers = runprops.get("nwalkers")
        startfromfile = runprops.get("startfromfile")
        nobjects = runprops.get("numobjects")
    
        name_dict = runprops.get("names_dict")
        objectnames = []
        for i in name_dict.values():
            objectnames.append(i)

#==============================================================================================
#If you are starting from a previous run
        if runprops['chain_file'] != None:
            print(runprops.get('results_folder'))
            nwalkers = runprops.get('nwalkers')
            float_names = runprops.get('float_names')
            ndim = len(float_names)
            fixed_df = pd.read_csv(runprops.get('runs_file')+'/fixed_df.csv')
            total_df_names = runprops.get('total_df_names')
            fit_scale = pd.read_csv(runprops.get('runs_file')+'/fit_scale.csv', index_col=0)
            obsdata = runprops.get('obsdata_file')
            obsdf = 0
            if os.path.exists(obsdata):
                if verbose:
                    print("Observational data file " + obsdata + " will be used")
                obsdf = pd.read_csv(obsdata)
            else:
                if verbose:
                    print("ERROR: No observational data file exists. Aborting run.")
                sys.exit()
        
            # Calculating the degrees of freedom
            nobservations = 0
            for i in range(1, nobjects):
                obsdata = obsdf["DeltaLat_" + objectnames[i]].values
                for j in range(len(obsdata)):
                    if not np.isnan(obsdata[j]):
                        nobservations += 1
                obsdata = obsdf["DeltaLong_" + objectnames[i]].values
                for j in range(len(obsdata)):
                    if not np.isnan(obsdata[j]):
                        nobservations += 1
            best_llhoods['deg_freedom'] = nobservations - ndim
            
            # Check to see if geocentric_object_position.csv exists and if not creates it
            objname = runprops.get('objectname')
            geofile = runprops.get('runs_file')+'/geocentric_' + objname + '_position.csv'
            geo_analysis = runprops.get('runs_file')+'/geocentric_' + objname + '_position_analysis.csv'

            if os.path.exists(geofile):
                if verbose:
                    print("File " + geofile + " will be used")
            else:
                if verbose:
                    print("No object geocentric position file exists. Creating new file.")
                times = obsdf['time'].tolist()
                mm_make_geo_pos.mm_make_geo_pos(objname, times, runprops)
                if verbose:
                    print("geocentric_" + objname + "_position.csv has been created")
            
            # Reads in th geocentric_object data file
            geo_obj_pos = pd.read_csv(geofile)
            shutil.copy(geofile, runprops.get('results_folder')+'/geocentric_'+runprops.get('objectname')+'_position.csv')
            shutil.copy(geo_analysis, runprops.get('results_folder')+'/geocentric_'+runprops.get('objectname')+'_position_analysis.csv')
            
    
            backend = emcee.backends.HDFBackend(runprops.get('chain_file'))
            
            moveset = [(emcee.moves.DEMove(), 0.8), (emcee.moves.DESnookerMove(), 0.2),]
            moveset = [(emcee.moves.StretchMove(), 1.0),]
            
            the_names = []
            for i in total_df_names:
                the_names.append(i)
            '''    
            print(runprops.get('results_folder'))
            if runprops.get('updatebestfitfile'):
                the_file = runprops.get('results_folder') + '/best_likelihoods.csv'
                with open(the_file, 'a+', newline='') as write_obj:
                    csv_writer = writer(write_obj, delimiter = ',')
                    the_names.insert(0,'Prior')
                    the_names.insert(0,'Reduced chi-sq')
                    the_names.insert(0,'Chi-sq')
                    the_names.insert(0,'P-val')                   
                    the_names.insert(0,'Likelihood')
                    for i in range(runprops.get('numobjects')-1):
                        the_names.append('Residuals_Lon_Obj_'+str(i+1))
                        the_names.append('Residuals_Lat_Obj_'+str(i+1))
                    csv_writer.writerow(the_names)
            '''        
            #print(os.getcwd())
            #print(runprops.get('chain_file'))
            #print(emcee.backends.HDFBackend(runprops.get('chain_file')).get_last_sample())
            fit_scale.to_csv(runprops.get("results_folder")+"/fit_scale.csv")
            fixed_df.to_csv(runprops.get('results_folder')+'/fixed_df.csv')
            runpath = runprops.get("results_folder")+"/runprops.txt"

            new_props = runprops.copy()
            del new_props['best_llhood']
            
            with open(runpath, 'w') as file:
                file.write(json.dumps(new_props, indent = 4))
            
            if runprops.get('is_mcmc') == False:
                runprops['is_mcmc'] = True
            sampler = emcee.EnsembleSampler(nwalkers, ndim, 
            mm_likelihood.log_probability, backend=backend, pool = pool,
            args = (float_names, fixed_df, total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods),
            moves = moveset)
            print('sampler created')
    
        #Starting the burnin
        # BP TODO: autoburnin??
        # So looking at how the emcee documentation does burn ins while saving the file, it seems like
        # the best way to do a run is to just do a single long run until the ess > 100 and cut the 
        # burn in off afterwards. This way you can save the whole chain and you can really analyze where to
        # cut off the burn in.
        # I think i want to still create an autoburnin but I really would like to look at a completed
        # run to see what the burn in looks like... It should be a few autocorrelation times
        
            nthinning = runprops.get('nthinning')
            '''
            nburnin = runprops.get("nburnin")
            nthinning = runprops.get('nthinning')
            if verbose:
                print("Starting the burn in")
            if nburnin != 0:
                if runprops.get('thin_run'):
                    state = sampler.run_mcmc(None, nburnin, progress = True, store = True, thin=nthinning)
                else:
                    state = sampler.run_mcmc(None, nburnin, progress = True, store = True)
            else:
                state = 0
    
            # Now running the clustering algorithm! (if desired)
            if runprops.get("use_clustering") and nburnin != 0:
                sampler, state = mm_clustering.mm_clustering(sampler, state, float_names, fixed_df, total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods, backend, pool, mm_likelihood, ndim, moveset)
        
            #sampler.reset()
            '''
    # Now do the full run with essgoal and initial n steps
            nsteps = runprops.get("nsteps")
            if runprops.get('thin_run'):
                state = sampler.run_mcmc(None, nsteps, progress = True, store = True, thin=nthinning)
            else:
                state = sampler.run_mcmc(None, nsteps, progress = True, store = True)
            
            essgoal = runprops.get("essgoal")
            maxiter = runprops.get("maxiter")
            initsteps = runprops.get("nsteps")
            
            p0=None
        
            #sampler,ess = mm_autorun.mm_autorun(sampler, essgoal, state, initsteps, maxiter, verbose, objname, p0, runprops)
        
            #print("effective sample size = ", ess)
            chain = sampler.get_chain(flat = False)
            flatchain = sampler.get_chain(flat = True)
        
    # Begin analysis!
            print('Beginning mm_analysis plots')
            runpath = runprops.get("results_folder")+"/runprops.txt"
            #runprops['total_df_names'] = runprops.get('total_df_names').to_numpy().tolist()
            del runprops['best_llhood']
            
            with open(runpath, 'w') as file:
                file.write(json.dumps(runprops, indent = 4))
    
            recent_props = runprops.get("runs_file")+"/most_recent_runprops.txt"
            with open(recent_props, 'w') as file:
                file.write(json.dumps(runprops, indent = 4))
    
            
            import mm_plots_multi
            mm_plots_multi.plots(backend, fit_scale, float_names, obsdf, runprops, geo_obj_pos, fixed_df, total_df_names)
        
                
            if runprops.get('build_init_from_llhood'):
                csvfile = runprops.get("results_folder")+"/best_likelihoods.csv"
                likelihoods = pd.read_csv(csvfile, sep = '\t', header = 0)
            
            
                params = likelihoods.iloc[[-1]].transpose()
                params = params.drop(['Likelihood'], axis=0)
                for i in range(runprops.get('numobjects')-1):
                    params = params.drop(['Residuals_Lat_Obj_'+str(i+1),'Residuals_Lon_Obj_'+str(i+1)], axis =0)

                init_guess = pd.read_csv(runprops.get('init_filename'))
                stddev  = init_guess['stddev'].tolist()

                params['stddev'] = stddev
                params.columns = ['mean', 'stddev']
            #print(params)
                new_init = "../data/"+runprops.get("objectname")+"/"+runprops.get("objectname")+"_init_guess_from_llhood.csv"
                params.to_csv(new_init, sep = ',')

            
    

#=============================================================================================================================
#If you are not starting from a previous run
        else:
            guesses = mm_init_guess.mm_init_guess(runprops)	# maybe more args
        # ouptut from init_guess is a dataframe with all the desired parameters to be fit
        # Getting relevant checking flags from runprops
            dynamicstoincludeflags = runprops.get("dynamicstoincludeflags")
            includesun = runprops.get("includesun")
            com_offset = runprops.get("com_offset")
            paramnames = list(sum(list(guesses), ()))
        # Check to make sure that numobjects equals length of dynamics flag
            if len(dynamicstoincludeflags) != runprops.get("numobjects"):
                print("ERROR: Number of objects given in runprops.txt does not match the length of dynamicstoincludeflags")
                sys.exit()
        
        # Now checking each object sequentially
            print(paramnames)
            
            j = 0
            for i in runprops.get("names_dict"):
                j = j+1
            
            if j > runprops.get("numobjects"):
                print("You have ", j," objects listed in your names_dict, but ",runprops.get("numobjects")," in your runprops. Please make sure they are equal before running again")
                sys.exit()
            for i in range(runprops.get("numobjects")):
                if i == 0:
                    if dynamicstoincludeflags[i] == "0":
                        if not (("mass_" + str(i+1) in paramnames)):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                            if (("sprate_" + str(i+1) in paramnames) or ("j2r2_" + str(i+1) in paramnames) or
                        ("spinc_" + str(i+1) in paramnames) or ("splan_" + str(i+1) in paramnames) or
                ("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                                print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                                sys.exit()
                    elif dynamicstoincludeflags[i] == "1":
                        if not (("mass_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                    ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames) and (("sprate_" + str(i+1) in paramnames) or ("period_" + str(i+1) in paramnames))):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                        if (("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                    elif dynamicstoincludeflags[i] == "2":
                        if not (("mass_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                        ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames) and
                        ("c22r2_" + str(i+1) in paramnames) and ("spaop_" + str(i+1) in paramnames) and
                        (("sprate_" + str(i+1) in paramnames) or ("period_" + str(i+1) in paramnames))):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                    else:
                        print("ERROR: dynamicstoincludeflags contains unallowed numbers. Allowed numbers are 0, 1, 2.")
                        sys.exit()
                else:
                    if dynamicstoincludeflags[i] == "0":
                        if not (("mass_" + str(i+1) in paramnames) and ("sma_" + str(i+1) in paramnames) and
                        ("ecc_" + str(i+1) in paramnames) and ("inc_" + str(i+1) in paramnames) and
                        ("aop_" + str(i+1) in paramnames) and ("lan_" + str(i+1) in paramnames) and
                        ("mea_" + str(i+1) in paramnames)):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                        if (("sprate_" + str(i+1) in paramnames) or ("j2r2_" + str(i+1) in paramnames) or
                    ("spinc_" + str(i+1) in paramnames) or ("splan_" + str(i+1) in paramnames) or
                    ("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                    elif dynamicstoincludeflags[i] == "1":
                        if not (("mass_" + str(i+1) in paramnames) and ("sma_" + str(i+1) in paramnames) and
                        ("ecc_" + str(i+1) in paramnames) and ("inc_" + str(i+1) in paramnames) and
                        ("aop_" + str(i+1) in paramnames) and ("lan_" + str(i+1) in paramnames) and
                        ("mea_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                                ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames) and ("sprate_" + str(i+1) in paramnames)):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                        if (("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                    elif dynamicstoincludeflags[i] == "2":
                        if not (("mass_" + str(i+1) in paramnames) and ("sma_" + str(i+1) in paramnames) and
                        ("ecc_" + str(i+1) in paramnames) and ("inc_" + str(i+1) in paramnames) and
                        ("aop_" + str(i+1) in paramnames) and ("lan_" + str(i+1) in paramnames) and
                        ("mea_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                                ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames) and
                        ("c22r2_" + str(i+1) in paramnames) and ("spaop_" + str(i+1) in paramnames) and
                        ("sprate_" + str(i+1) in paramnames)):
                            print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                            sys.exit()
                    else:
                        print("ERROR: dynamicstoincludeflags contains unallowed numbers. Allowed numbers are 0, 1, 2.")
                        sys.exit()
            
            # Now checking the includesun flag


            #if includesun:
            #if not (("mass_0" in paramnames) and ("sma_0" in paramnames) and
            #        ("ecc_0" in paramnames) and ("inc_0" in paramnames) and
            #        ("aop_0" in paramnames) and ("lan_0" in paramnames) and
            #        ("mea_0" in paramnames)):
            #        print("ERROR: includesun flag does not match inputs.")
            #        sys.exit()


            if not includesun:
                if (("mass_0" in paramnames) or ("sma_0" in paramnames) or
                ("ecc_0" in paramnames) or ("inc_0" in paramnames) or
                ("aop_0" in paramnames) or ("lan_0" in paramnames) or
                ("mea_0" in paramnames)):
                    print("ERROR: includesun flag does not match inputs.")
                    sys.exit()
        
            # Now checking the com_offset flag
            if com_offset:
                if not (("lat_offset" in paramnames) and ("long_offset" in paramnames)):
                    print("ERROR: com_offset flag does not match inputs.")
                    sys.exit()
            if not com_offset:
                if (("lat_offset" in paramnames) or ("long_offset" in paramnames)):
                    print("ERROR: com_offset flag does not match inputs.")
                    sys.exit()
        
            #ndim is equal to the number of dimension, should this be equal to the number of columns of the init_guess array?
         
            # Convert the guesses into fitting units and place in numpy array
            p0,float_names,fixed_df,total_df_names,fit_scale,fit_names = mm_param.from_param_df_to_fit_array(guesses,runprops)
            
            #print("outside",float_names, total_df_names, fit_scale)
            fixed_df.to_csv(runprops.get('results_folder')+'/fixed_df.csv')
            fit_scale.to_csv(runprops.get('results_folder')+'/fit_scale.csv')
            runprops['float_names'] = float_names
            runprops['total_df_names'] = total_df_names
            
            runpath = runprops.get("results_folder")+"/runprops.txt"
            new_props = runprops.copy()
            new_props['total_df_names'] = runprops.get('total_df_names').tolist()
            del new_props['best_llhood']
            
            with open(runpath, 'w') as file:
                file.write(json.dumps(new_props, indent = 4))
            new_props['best_llhoods'] = -np.inf
            runprops['best_llhood'] = -np.inf
            ndim = len(p0[0])
            #we still do not have a constraints or fit scale defined
            
            # Now get observations data frame
            # DS TODO: take observations data frame from runprops
            obsdata = '../runs/'+runprops.get('objectname')+'/observations/'+runprops.get('obs_df')
            obsdf = 0
            #print(obsdata, os.getcwd())
            if os.path.exists(obsdata):
                if verbose:
                    print("Observational data file " + obsdata + " will be used")
                obsdf = pd.read_csv(obsdata, index_col = 0)
            else:
                
                print("ERROR: No observational data file exists at "+obsdata+". Aborting run.")
                sys.exit()
        
            # Calculating the degrees of freedom
            nobservations = 0
            #print(obsdf, obsdf.columns)
            for i in range(1, nobjects):
                obsdata = obsdf["DeltaLat_" + objectnames[i]].values
                for j in range(len(obsdata)):
                    if not np.isnan(obsdata[j]):
                        nobservations += 1
                obsdata = obsdf["DeltaLong_" + objectnames[i]].values
                for j in range(len(obsdata)):
                    if not np.isnan(obsdata[j]):
                        nobservations += 1
            best_llhoods['deg_freedom'] = nobservations - ndim
            
            # Check to see if geocentric_object_position.csv exists and if not creates it
            objname = runprops.get('objectname')
            geofile = runprops.get('runs_file')+'/geocentric_' + objname + '_position.csv'
            geo_analysis = runprops.get('runs_file')+'/geocentric_' + objname + '_position_analysis.csv'
            if os.path.exists(geofile):
                if verbose:
                    print("File " + geofile + " will be used")
            else:
                if verbose:
                    print("No object geocentric position file exists. Creating new file.")
                times = obsdf['time'].tolist()
                mm_make_geo_pos.mm_make_geo_pos(objname, times, runprops)
                if verbose:
                    print("geocentric_" + objname + "_position.csv has been created")
            
            # Reads in th geocentric_object data file
            geo_obj_pos = pd.read_csv(geofile, index_col=0)
            shutil.copy(geofile, runprops.get('results_folder')+'/geocentric_'+objname+'_position.csv')
            #shutil.copy(geo_analysis, runprops.get('results_folder')+'/geocentric_'+objname+'_position_analysis.csv')
            
            # Go through initial guesses and check that all walkers have finite posterior probability
            reset = 0
            maxreset = runprops.get("maxreset")
            print('Testing to see if initial params are valid')
            
            the_names = []
            for i in total_df_names:
                the_names.append(i)
            #for i in fit_names:
            #    the_names.append(i)

            if runprops.get('updatebestfitfile'):
                the_file = runprops.get('results_folder') + '/best_likelihoods.csv'
                with open(the_file, 'a+', newline='') as write_obj:
                    csv_writer = writer(write_obj, delimiter = ',')
                    the_names.insert(0,'Prior')
                    the_names.insert(0,'Reduced_chi_sq')
                    the_names.insert(0,'Chi-sq')
                    the_names.insert(0,'P-val')
                    the_names.insert(0,'Degrees-of-freedom')
                    the_names.insert(0,'Likelihood')
                    #the_names.insert(0,'index')
                    for i in range(runprops.get('numobjects')-1):
                        the_names.append('Residuals_Lon_Obj_'+str(i+1))
                        the_names.append('Residuals_Lat_Obj_'+str(i+1))
                    csv_writer.writerow(the_names)
            
            if runprops.get('op_mode'):
                import mm_optimize
                runprops["is_mcmc"] = True
                #print('start optimize 1')
                p0 = mm_optimize.mm_optimize(nwalkers, p0, float_names, fixed_df, total_df_names, fit_scale, runprops, obsdf, geo_obj_pos, best_llhoods, pool)
                import corner
                import matplotlib.pyplot as plt
                p0 = np.array(p0)
                names = []
                #print(float_names)    
                for i in float_names:
                    names.append(i)
                    
                undo_ecc_aop = np.zeros(runprops.get('numobjects')-1)
                undo_ecc_aop[:] = False
                ecc_aop_index = np.zeros((runprops.get('numobjects')-1)*2)
                undo_inc_lan = np.zeros(runprops.get('numobjects')-1)
                undo_inc_lan[:] = False
                undo_spin = np.zeros(runprops.get('numobjects')-1)
                undo_spin[:] = False
                spin_index = np.zeros((runprops.get('numobjects')-1)*2)
                inc_lan_index = np.zeros((runprops.get('numobjects')-1)*2)
                undo_lambda = np.zeros(runprops.get('numobjects')-1)
                undo_lambda[:] = False
                lambda_index = np.zeros((runprops.get('numobjects')-1)*2)
                undo_pomega = np.zeros(runprops.get('numobjects')-1)
                undo_pomega[:] = False
                pomega_index = np.zeros((runprops.get('numobjects')-1)*2)
                undo_masses = np.zeros(2)    
                undo_masses[:] = False
                masses_index = np.zeros(runprops.get('numobjects'))
                
                for i in range(runprops.get('numobjects')-1):
                    if 'ecc_'+str(i+2) in float_names and 'aop_'+str(i+2) in float_names:
                        undo_ecc_aop[i] = True
                        ecc_aop_index[2*i] = float_names.index('ecc_'+str(i+2))
                        ecc_aop_index[2*i+1] = float_names.index('aop_'+str(i+2))
                    if 'inc_'+str(i+2) in float_names and 'lan_'+str(i+2) in float_names:
                        undo_inc_lan[i] = True
                        inc_lan_index[2*i] = float_names.index('inc_'+str(i+2))
                        inc_lan_index[2*i+1] = float_names.index('lan_'+str(i+2))
                    if 'spinc_'+str(i+2) in float_names and 'splan_'+str(i+2) in float_names:
                        undo_spin[i] = True
                        spin_index[2*i] = float_names.index('spinc_'+str(i+2))
                        spin_index[2*i+1] = float_names.index('splan_'+str(i+2))
                    if 'mea_'+str(i+2) in float_names and 'aop_'+str(i+2) in float_names:
                        undo_lambda[i] = True
                        lambda_index[2*i] = float_names.index('mea_'+str(i+2))
                        lambda_index[2*i+1] = float_names.index('aop_'+str(i+2))
                    if 'aop_'+str(i+2) in float_names and 'lan_'+str(i+2) in float_names:
                        undo_pomega[i] = True
                        pomega_index[2*i] = float_names.index('aop_'+str(i+2))
                        pomega_index[2*i+1] = float_names.index('lan_'+str(i+2))
                if 'mass_1' in float_names and 'mass_2' in float_names:
                    if 'mass_3' in float_names and runprops.get('numobjects') > 2:        
                        undo_masses[1] = True
                        masses_index[0] = float_names.index('mass_1')
                        masses_index[1] = float_names.index('mass_2')
                        masses_index[2] = float_names.index('mass_3')
                    else:        
                        undo_masses[0] = True
                        masses_index[0] = float_names.index('mass_1')
                        masses_index[1] = float_names.index('mass_2')
            
                fit = []
        
                for i in fit_scale.columns:
                    name = i
                    if type(name) != str:
                        name = name[0]
                    if name in float_names:
                        val = fit_scale.loc[0, i]
                        fit.append(val)
            
                numparams = len(fit)
                p0_copy = np.copy(p0)
                #print(p0_copy)
                # Take chain "fit" values and make them into real values
                for i in range(numparams):
                    p0_copy[:,i] = p0_copy[:,i]*fit[i]
                #print(p0_copy)
                # Now de-transform the chain
                print("Starting un transformations")
                if runprops.get("transform"):
                    for b in range(runprops.get('numobjects')-1):
                        if undo_ecc_aop[b]:
                            aop_new = p0_copy[:,int(ecc_aop_index[b*2+1])]
                            ecc_new = p0_copy[:,int(ecc_aop_index[b*2])]
                            pomega = (np.arctan2(ecc_new,aop_new)*180/np.pi)%360
                            p0_copy[:,int(ecc_aop_index[b*2+1])] = pomega
                            p0_copy[:,int(ecc_aop_index[b*2])] = ecc_new/np.sin(pomega/180*np.pi)
                        if undo_inc_lan[b]:
                            inc_new = p0_copy[:,int(inc_lan_index[b*2])]
                            lan_new = p0_copy[:,int(inc_lan_index[b*2+1])]
                            lan = (np.arctan2(inc_new,lan_new)*180/np.pi)%360
                            p0_copy[:,int(inc_lan_index[b*2+1])] = lan
                            inc = (np.arctan2(inc_new,np.sin(lan*np.pi/180))*2*180/np.pi)%180
                            p0_copy[:,int(inc_lan_index[b*2])] = inc
                        if undo_spin[b]:
                            spinc_new = p0_copy[:,int(spin_index[b*2])]
                            splan_new = p0_copy[:,int(spin_index[b*2+1])]
                            splan = (np.arctan2(spinc_new,splan_new)*180/np.pi)%360
                            p0_copy[:,int(spin_index[b*2+1])] = lan
                            spinc = (np.arctan2(spinc_new,np.sin(splan*np.pi/180))*2*180/np.pi)%180
                            p0_copy[:,int(spin_index[b*2])] = spinc
                        if undo_lambda[b]:
                            mea_new = p0_copy[:,int(lambda_index[b*2])]
                            pomega = p0_copy[:,int(lambda_index[b*2+1])]
                            mea = (mea_new-pomega)%360
                            p0_copy[:,int(lambda_index[b*2])] = mea
                        if undo_pomega[b]:
                            lan = p0_copy[:,int(pomega_index[b*2+1])]
                            pomega = p0_copy[:,int(pomega_index[b*2])]
                            aop = (pomega-lan)%360
                            p0_copy[:,int(pomega_index[b*2])] = aop
                    if undo_masses[0]:
                        mass_1 = p0_copy[:,int(masses_index[0])]
                        mass_2 = p0_copy[:,int(masses_index[1])]
                        p0_copy[:,int(masses_index[1])] = mass_2-mass_1
                    elif undo_masses[1]:
                        mass_1 = p0_copy[:,int(masses_index[0])]
                        mass_2 = p0_copy[:,int(masses_index[1])]
                        mass_3 = p0_copy[:,int(masses_index[2])]
                        p0_copy[:,int(masses_index[2])] = (mass_3-mass_2)/(10**18) 
                        p0_copy[:,int(masses_index[1])] = (mass_2-mass_1)/(10**18)
                        p0_copy[:,int(masses_index[0])] = (mass_1)/(10**18)
                
                #print(p0_copy)
                latexnames = names.copy()
                for i in range(len(latexnames)):
                    if "mass" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("mass","m")+"$ ($10^{18}$ kg)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "sma" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("sma","a")+"$ (km)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "ecc" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("ecc","e")+"$"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "aop" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("aop","\omega")+"$ ($^{\circ}$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "inc" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("inc","i")+"$ ($^{\circ}$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "lan" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("lan","\Omega")+"$ ($^{\circ}$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "mea" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("mea","M")+"$ ($^{\circ}$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "j2r2" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("j2r2","J_2R^2")+"$ (km$^2$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "spinc" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("spinc","i^{spin}")+"$ ($^{\circ}$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "splan" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("splan","\Omega^{spin}")+"$ ($^{\circ}$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "c22r2" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("c22r2","C_{22}R^2")+"$ (km$^2$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "spaop" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("spaop","\omega^{spin}")+"$ ($^{\circ}$)"
                        latexnames[i] = fr"{latexnames[i]}"
                    if "sprate" in latexnames[i]:
                        latexnames[i] = "$"+latexnames[i].replace("sprate","")+"$ (rad s$^{-1}$)"
                        latexnames[i] = fr"{latexnames[i]}"    
                
                fig = corner.corner(p0_copy, labels = latexnames, bins = 40, show_titles = True, 
                                    plot_datapoints = False, color = "blue", fill_contours = True,
                                    title_fmt = ".3f", label_kwargs=dict(fontsize=20))
                fig.show()
                fname = runprops.get('results_folder')+"/opt_corner.pdf"       
                fig.savefig(fname, format = 'pdf')
                #print("Saved at ",fname)
                plt.close("all")
                #sys.exit()
                
            else:
                runprops["is_mcmc"] = False
                #print(float_names, total_df_names, fit_scale)
                for i in tqdm(range(nwalkers)):  
                    llhood = mm_likelihood.log_probability(p0[i,:], float_names,fixed_df.iloc[[i]],total_df_names, fit_scale, runprops, obsdf, geo_obj_pos, best_llhoods)
                    reset = 0
                    #print(llhood)
                    while (llhood == -np.Inf):
                        p = random.random()
                        p0[i,:] = (p*p0[random.randrange(nwalkers),:] + (1-p)*p0[random.randrange(nwalkers),:])
                        llhood = mm_likelihood.log_probability(p0[i,:], float_names,fixed_df,total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods)
                        reset += 1
                        if reset > maxreset:
                            print("ERROR: Maximum number of resets has been reached, aborting run.")
                            sys.exit() 
            
        
            runprops["is_mcmc"] = True
        
            # We now have an initial guess for each walker that is not really bad.
            # Begin MCMC
            p0 = list(p0)
            # Now creating the sampler object
            filename = runprops.get("results_folder")+ "/chain.h5"
            
            # BP TODO: make an option in runprops to start from the end of another run and just append it
            
            backend = emcee.backends.HDFBackend(filename)
            backend.reset(nwalkers, ndim)
            moveset = [(emcee.moves.DEMove(), 0.8), (emcee.moves.DESnookerMove(), 0.2),]
            moveset = [(emcee.moves.StretchMove(), 1.0),]
            
            
            
            
            sampler = emcee.EnsembleSampler(nwalkers, ndim, 
            mm_likelihood.log_probability, backend=backend, pool=pool,
                    args = (float_names, fixed_df, total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods),
                    moves = moveset)
            print('sampler created')
        
            #Starting the burnin
            # BP TODO: autoburnin??
            # So looking at how the emcee documentation does burn ins while saving the file, it seems like
            # the best way to do a run is to just do a single long run until the ess > 100 and cut the 
            # burn in off afterwards. This way you can save the whole chain and you can really analyze where to
            # cut off the burn in.
            # I think i want to still create an autoburnin but I really would like to look at a completed
            # run to see what the burn in looks like... It should be a few autocorrelation times
            
            nburnin = runprops.get("nburnin")
            nthinning = runprops.get("nthinning")
            if verbose:
                print("Starting the burn in")
            if runprops.get('thin_run'):
                state = sampler.run_mcmc(p0, nburnin, progress = True, store = True, thin=nthinning)
            else:
                state = sampler.run_mcmc(p0, nburnin, progress = True, store = True)
        
                # Now running the clustering algorithm! (if desired)
            if runprops.get("use_clustering") and nburnin != 0:
                sampler, state = mm_clustering.mm_clustering(sampler, state, float_names, fixed_df, total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods, backend, pool, mm_likelihood, ndim, moveset)
                
                #sampler.reset()
        
            # Now do the full run with essgoal and initial n steps
            
            nsteps = runprops.get("nsteps")
            essgoal = runprops.get("essgoal")
            maxiter = runprops.get("maxiter")
            initsteps = runprops.get("nsteps")
                
            sampler,ess = mm_autorun.mm_autorun(sampler, essgoal, state, initsteps, maxiter, verbose, objname, p0, runprops)
                
            print("effective sample size = ", ess)
            chain = sampler.get_chain(thin = runprops.get("nthinning"))
            flatchain = sampler.get_chain(flat = True, thin = runprops.get("nthinning"))
            
            # Begin analysis!
            #print('Beginning mm_analysis plots')
            
            
            #mm_analysis.plots(sampler, guesses.columns, objname, fit_scale, float_names, obsdf, runprops, geo_obj_pos, mm_make_geo_pos, fixed_df, total_df_names)
            
            runpath = runprops.get("results_folder")+"/runprops.txt"
            runprops['total_df_names'] = runprops.get('total_df_names').tolist()
            del runprops['best_llhood']
            
            with open(runpath, 'w') as file:
                file.write(json.dumps(runprops, indent = 4))
                
            recent_props = runprops.get("runs_file")+"/most_recent_runprops.txt"
            with open(recent_props, 'w') as file:
                file.write(json.dumps(runprops, indent = 4))
            
            backendf = runprops.get('results_folder')+'chain.h5'
            backend = emcee.backends.HDFBackend(backendf)
            os.chdir(runprops.get("results_folder"))
            
            import mm_plots_multi
            mm_plots_multi.plots(backend, fit_scale, float_names, obsdf, runprops, geo_obj_pos, fixed_df, total_df_names)
            
            if runprops.get('build_init_from_llhood'):
                csvfile = runprops.get("results_folder")+"/best_likelihoods.csv"
                likelihoods = pd.read_csv(csvfile, sep = '\t', header = 0)
                
                
                params = likelihoods.iloc[[-1]].transpose()
                params = params.drop(['Likelihood'], axis=0)
                for i in range(runprops.get('numobjects')-1):
                    params = params.drop(['Residuals_Lat_Obj_'+str(i+1),'Residuals_Lon_Obj_'+str(i+1)], axis =0)
        
                init_guess = pd.read_csv(runprops.get('init_filename'))
                stddev  = init_guess['stddev'].tolist()
        
                params['stddev'] = stddev
                params.columns = ['mean', 'stddev']
                #print(params)
                new_init = "../data/"+runprops.get("objectname")+"/"+runprops.get("objectname")+"_init_guess_from_llhood.csv"
                params.to_csv(new_init, sep = ',')
                
        
            # make other diagnostic plots
            # TODO: orbit astrometry plots
            # TODO: residual plots
            
def run():
    sys, np, pd, emcee, random, h5py, mm_runprops, mm_init_guess, mm_likelihood, mm_make_geo_pos, mm_priors, mm_relast, mm_autorun, mm_param, mm_clustering, os, mm_analysis, Pool, warnings, shutil, json, writer, Manager = initializer()
    
    manager = Manager()
    best_llhoods = manager.dict()
    best_llhoods['best_llhood'] = -np.inf
    best_llhoods['best_params'] = []

    runprops = mm_runprops.runprops
    runprops['best_llhood'] = -np.inf

    verbose = runprops.get("verbose")
    nwalkers = runprops.get("nwalkers")
    startfromfile = runprops.get("startfromfile")
    nobjects = runprops.get("numobjects")

    name_dict = runprops.get("names_dict")
    objectnames = []
    for i in name_dict.values():
        objectnames.append(i)

# BP TODO: make an option in runprops to start from the end of another run and just append it
# Generate the intial guess for emcee
# starting guess is given by the user as specified in runprops
# and turned into the official initial guess

# LATER TODO: starting -> initial guess function is specificed by user

    guesses = mm_init_guess.mm_init_guess(runprops)	# maybe more args
# ouptut from init_guess is a dataframe with all the desired parameters to be fit

# Getting relevant checking flags from runprops
    dynamicstoincludeflags = runprops.get("dynamicstoincludeflags")
    includesun = runprops.get("includesun")
    paramnames = list(sum(list(guesses), ()))
# Check to make sure that numobjects equals length of dynamics flag
    if len(dynamicstoincludeflags) != runprops.get("numobjects"):
        print("ERROR: Number of objects given in runprops.txt does not match the length of dynamicstoincludeflags")
        sys.exit()

# Now checking each object sequentially
    for i in range(runprops.get("numobjects")):
        if i == 0:
            if dynamicstoincludeflags[i] == "0":
                if not (("mass_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
                if (("sprate_" + str(i+1) in paramnames) or ("j2r2_" + str(i+1) in paramnames) or
            ("spinc_" + str(i+1) in paramnames) or ("splan_" + str(i+1) in paramnames) or
            ("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
            elif dynamicstoincludeflags[i] == "1":
                if not (("mass_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
                if (("sprate_" + str(i+1) in paramnames) or
            ("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
            elif dynamicstoincludeflags[i] == "2":
                if not (("mass_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames) and
                ("c22r2_" + str(i+1) in paramnames) and ("spaop_" + str(i+1) in paramnames) and
                ("sprate_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
            else:
                print("ERROR: dynamicstoincludeflags contains unallowed numbers. Allowed numbers are 0, 1, 2.")
                sys.exit()
        else:
            if dynamicstoincludeflags[i] == "0":
                if not (("mass_" + str(i+1) in paramnames) and ("sma_" + str(i+1) in paramnames) and
                ("ecc_" + str(i+1) in paramnames) and ("inc_" + str(i+1) in paramnames) and
                ("aop_" + str(i+1) in paramnames) and ("lan_" + str(i+1) in paramnames) and
                ("mea_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
                if (("sprate_" + str(i+1) in paramnames) or ("j2r2_" + str(i+1) in paramnames) or
            ("spinc_" + str(i+1) in paramnames) or ("splan_" + str(i+1) in paramnames) or
            ("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
            elif dynamicstoincludeflags[i] == "1":
                if not (("mass_" + str(i+1) in paramnames) and ("sma_" + str(i+1) in paramnames) and
                ("ecc_" + str(i+1) in paramnames) and ("inc_" + str(i+1) in paramnames) and
                ("aop_" + str(i+1) in paramnames) and ("lan_" + str(i+1) in paramnames) and
                ("mea_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                        ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
                if (("sprate_" + str(i+1) in paramnames) or
            ("c22r2_" + str(i+1) in paramnames) or ("spaop_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
            elif dynamicstoincludeflags[i] == "2":
                if not (("mass_" + str(i+1) in paramnames) and ("sma_" + str(i+1) in paramnames) and
                ("ecc_" + str(i+1) in paramnames) and ("inc_" + str(i+1) in paramnames) and
                ("aop_" + str(i+1) in paramnames) and ("lan_" + str(i+1) in paramnames) and
                ("mea_" + str(i+1) in paramnames) and ("j2r2_" + str(i+1) in paramnames) and
                        ("spinc_" + str(i+1) in paramnames) and ("splan_" + str(i+1) in paramnames) and
                ("c22r2_" + str(i+1) in paramnames) and ("spaop_" + str(i+1) in paramnames) and
                ("sprate_" + str(i+1) in paramnames)):
                    print("ERROR: dynamics to include flags does not match the input parameters for object " + str(i+1))
                    sys.exit()
            else:
                print("ERROR: dynamicstoincludeflags contains unallowed numbers. Allowed numbers are 0, 1, 2.")
                sys.exit()
    
    # Now checking the includesun flag
    if includesun:
        if not (("mass_0" in paramnames) and ("sma_0" in paramnames) and
            ("ecc_0" in paramnames) and ("inc_0" in paramnames) and
            ("aop_0" in paramnames) and ("lan_0" in paramnames) and
            ("mea_0" in paramnames)):
            print("ERROR: includesun flag does not match inputs.")
            sys.exit()
    if not includesun:
        if (("mass_0" in paramnames) or ("sma_0" in paramnames) or
        ("ecc_0" in paramnames) or ("inc_0" in paramnames) or
        ("aop_0" in paramnames) or ("lan_0" in paramnames) or
        ("mea_0" in paramnames)):
            print("ERROR: includesun flag does not match inputs.")
            sys.exit()
        
    #ndim is equal to the number of dimension, should this be equal to the number of columns of the init_guess array?
 
    # Convert the guesses into fitting units and place in numpy array
    p0,float_names,fixed_df,total_df_names,fit_scale,fit_names = mm_param.from_param_df_to_fit_array(guesses,runprops)
    
    
    ndim = len(p0[0])
    #we still do not have a constraints or fit scale defined
    
    # Now get observations data frame
    # DS TODO: take observations data frame from runprops
    obsdata = runprops.get('obsdata_file')
    
    obsdf = 0
    if os.path.exists(obsdata):
        if verbose:
            print("Observational data file " + obsdata + " will be used")
        obsdf = pd.read_csv(obsdata)
    else:
        if verbose:
            print("ERROR: No observational data file exists. Aborting run.")
        sys.exit()

    # Calculating the degrees of freedom
    nobservations = 0
    for i in range(1, nobjects):
        obsdata = obsdf["DeltaLat_" + objectnames[i]].values
        for j in range(len(obsdata)):
            if not np.isnan(obsdata[j]):
                nobservations += 1
        obsdata = obsdf["DeltaLong_" + objectnames[i]].values
        for j in range(len(obsdata)):
            if not np.isnan(obsdata[j]):
                nobservations += 1
    best_llhoods['deg_freedom'] = nobservations - ndim
    
    # Check to see if geocentric_object_position.csv exists and if not creates it
    objname = runprops.get('objectname')
    if os.path.exists("../data/" + objname + "/geocentric_" + objname + "_position.csv"):
        if verbose:
            print("Object geocentric position file geocentric_" + objname + "_position.csv will be used")
    else:
        if verbose:
            print("No object geocentric position file exists. Creating new file.")
        times = obsdf['time'].tolist()
        mm_make_geo_pos.mm_make_geo_pos(objname, times)	# This is basically a function based on DS's makeHorFile
        if verbose:
            print("geocentric_" + objname + "_position.csv has been created")
    
    # Reads in th geocentric_object data file
    geo_obj_pos = pd.read_csv("../data/" + objname + "/geocentric_" + objname + "_position.csv")
    
    # Go through initial guesses and check that all walkers have finite posterior probability
    reset = 0
    maxreset = runprops.get("maxreset")
    
    print('Testing to see if initial params are valid')
    for i in range(nwalkers):  
        llhood = mm_likelihood.log_probability(p0[i,:], float_names,fixed_df.iloc[[i]],total_df_names, fit_scale, runprops, obsdf, geo_obj_pos, best_llhoods)
        reset = 0
        #print(llhood)
        while (llhood == -np.Inf):
            p = random.random()
            p0[i,:] = (p*p0[random.randrange(nwalkers),:] + (1-p)*p0[random.randrange(nwalkers),:])
            llhood = mm_likelihood.log_probability(p0[i,:], float_names,fixed_df,total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods)
            reset += 1
            print(llhood)
            if reset > maxreset:
                print("ERROR: Maximum number of resets has been reached, aborting run.")
                sys.exit() 
    runprops["is_mcmc"] = True

    # We now have an initial guess for each walker that is not really bad.
    # Begin MCMC
    p0 = list(p0)
    # Now creating the sampler object
    filename = "../runs/" + runprops.get("objectname") + "_" + runprops.get("date") + "/chain.h5"
    
    # BP TODO: make an option in runprops to start from the end of another run and just append it
    
    backend = emcee.backends.HDFBackend(filename)
    backend.reset(nwalkers, ndim)
    moveset = [(emcee.moves.DEMove(), 0.8), (emcee.moves.DESnookerMove(), 0.2),]
    moveset = [(emcee.moves.StretchMove(), 1.0),]
    
    the_names = []
    for i in total_df_names:
        the_names.append(i[0])
    
    if runprops.get('updatebestfitfile'):
        the_file = runprops.get('runs_folder') + '/best_likelihoods.csv'
        with open(the_file, 'a+', newline='') as write_obj:
            csv_writer = writer(write_obj, delimiter = ',')
            the_names.insert(0,'Prior')
            the_names.insert(0,'Reduced chi-sq')
            the_names.insert(0,'Likelihood')
            for i in range(runprops.get('numobjects')-1):
                the_names.append('Residuals_Lon_Obj_'+str(i+1))
                the_names.append('Residuals_Lat_Obj_'+str(i+1))
            #csv_writer.writerow(fit_names)
            csv_writer.writerow(the_names)
            
        
    with Pool(runprops.get("numprocesses")) as pool:
    
        sampler = emcee.EnsembleSampler(nwalkers, ndim, 
        mm_likelihood.log_probability, backend=backend, pool = pool,
            args = (float_names, fixed_df, total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods),
            moves = moveset)
        print('sampler created')

    #Starting the burnin
    # BP TODO: autoburnin??
    # So looking at how the emcee documentation does burn ins while saving the file, it seems like
    # the best way to do a run is to just do a single long run until the ess > 100 and cut the 
    # burn in off afterwards. This way you can save the whole chain and you can really analyze where to
    # cut off the burn in.
    # I think i want to still create an autoburnin but I really would like to look at a completed
    # run to see what the burn in looks like... It should be a few autocorrelation times
    
        nburnin = runprops.get("nburnin")
        if verbose:
            print("Starting the burn in")
    
        state = sampler.run_mcmc(p0, nburnin, progress = True, store = True)

        # Now running the clustering algorithm! (if desired)
        print(runprops.get("nburnin"))
        if runprops.get("use_clustering") and runprops.get("nburnin") != 0:
            sampler, state = mm_clustering.mm_clustering(sampler, state, float_names, fixed_df, total_df_names, fit_scale, runprops, obsdf,geo_obj_pos, best_llhoods, backend, pool, mm_likelihood, ndim, moveset)
        
        #sampler.reset()

    # Now do the full run with essgoal and initial n steps
    
        nsteps = runprops.get("nsteps")
        essgoal = runprops.get("essgoal")
        maxiter = runprops.get("maxiter")
        initsteps = runprops.get("nsteps")
        
        sampler,ess = mm_autorun.mm_autorun(sampler, essgoal, state, initsteps, maxiter, verbose, objname, p0, runprops)
        
    print("effective sample size = ", ess)
    chain = sampler.get_chain(thin = runprops.get("nthinning"))
    flatchain = sampler.get_chain(flat = True, thin = runprops.get("nthinning"))
        
    # Begin analysis!
    print('Beginning mm_analysis plots')
    
    #mm_analysis.plots(sampler, guesses.columns, objname, fit_scale, float_names, obsdf, runprops, geo_obj_pos, mm_make_geo_pos)
    runpath = "../runs/"+runprops.get("objectname")+"_"+runprops.get("date")+"/runprops.txt"
    
    with open(runpath, 'w') as file:
        file.write(json.dumps(runprops, indent = 4))
        
    if runprops.get('build_init_from_llhood'):
        csvfile = "../runs/"+runprops.get("objectname")+"_"+runprops.get("date")+"/best_likelihoods.csv"
        likelihoods = pd.read_csv(csvfile, sep = '\t', header = 0)
        
        
        params = likelihoods.iloc[[-1]].transpose()
        params = params.drop(['Likelihood'], axis=0)
        for i in range(runprops.get('numobjects')-1):
            params = params.drop(['Residuals_Lat_Obj_'+str(i+1),'Residuals_Lon_Obj_'+str(i+1)], axis =0)

        init_guess = pd.read_csv(runprops.get('init_filename'))
        stddev  = init_guess['stddev'].tolist()

        params['stddev'] = stddev
        params.columns = ['mean', 'stddev']
        #print(params)
        new_init = "../data/"+runprops.get("objectname")+"/"+runprops.get("objectname")+"_init_guess_from_llhood.csv"
        params.to_csv(new_init, sep = ',')
